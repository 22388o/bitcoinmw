<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bitcoin Mimblewimble (BMW)"><title>bmw - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bmw" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.1 (7cf61ebde 2024-03-27)" data-channel="1.77.1" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bmw/index.html">bmw</a><span class="version">0.0.3-beta.2</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../bmw/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bmw</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/bmw/lib.rs.html#18-242">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bitcoin-mimblewimble-bmw"><a class="doc-anchor" href="#bitcoin-mimblewimble-bmw">§</a>Bitcoin Mimblewimble (BMW)</h2>
<p>                   <a href="https://dev.azure.com/mwc-project/bitcoinmw/_build?definitionId=13"><img src="https://dev.azure.com/mwc-project/bitcoinmw/_apis/build/status/cgilliard.bitcoinmw?branchName=main" alt="Build Status" /></a>
<a href="https://github.com/cgilliard/bitcoinmw/releases"><img src="https://img.shields.io/github/v/release/cgilliard/bitcoinmw.svg" alt="Release Version" /></a>
<a href="https://cgilliard.github.io/bitcoinmw/code_coverage.html"><img src="https://img.shields.io/static/v1?label=Code%20Coverage&amp;message=95.39%&amp;color=purple" alt="Code Coverage" /></a>
<a href="https://cgilliard.github.io/bitcoinmw/doc/bmw/index.html"><img src="https://img.shields.io/static/v1?label=Documentation&amp;message=Rustdoc&amp;color=red" alt="Docmentation" /></a>
<a href="https://github.com/cgilliard/bitcoinmw/blob/master/LICENSE"><img src="https://img.shields.io/github/license/cgilliard/bitcoinmw.svg" alt="License" /></a></p>
<p align="center">
 <img src="https://user-images.githubusercontent.com/7232183/183282880-e3fac338-7ea6-44ab-b7f2-40c605d297c2.jpeg"/>
 </p>
 <p align="center"> Core libraries for Bitcoin Mimblewimble (BMW).</p>
<h2 id="development-status"><a class="doc-anchor" href="#development-status">§</a>Development Status</h2>
<p>Bitcoin Mimblewimble (BMW) will eventually be a cryptocurrency. It will be based on these core libraries. As they are
available, we will document them here.</p>
<h2 id="bmw-eventhandler-crate"><a class="doc-anchor" href="#bmw-eventhandler-crate">§</a>BMW Eventhandler crate</h2>
<p>The BMW Eventhandler crate is used to handle events on tcp/ip connections. Both inbound and
outbound connections can be handled. It uses epoll on Linux, kqueues on MacOS, and Wepoll on
Windows. It is highly scalable and includes a performance measuring tool as well. A simple
example can be found below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_evh::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>std::str::from_utf8;

 <span class="macro">info!</span>();

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create an evh with the specified configuration.
     // This example shows all possible configuration options, but all of
     // are optional. See the macro's documentation for full details.
     </span><span class="kw">let </span><span class="kw-2">mut </span>evh = <span class="macro">evh_oro!</span>(
         EvhTimeout(<span class="number">100</span>), <span class="comment">// set timeout to 100 ms.
         </span>EvhThreads(<span class="number">1</span>), <span class="comment">// 1 thread
         </span>EvhReadSlabSize(<span class="number">100</span>), <span class="comment">// 100 byte slab size
         </span>EvhReadSlabCount(<span class="number">100</span>), <span class="comment">// 100 slabs
         </span>EvhHouseKeeperFrequencyMillis(<span class="number">1_000</span>), <span class="comment">// run the house keeper every 1_000 ms.
         </span>EvhStatsUpdateMillis(<span class="number">5_000</span>), <span class="comment">// return updated stats every 5_000 ms.
         </span>Debug(<span class="bool-val">true</span>) <span class="comment">// print additional debugging information.
     </span>)<span class="question-mark">?</span>;

     <span class="comment">// set the on read handler
     </span>evh.set_on_read(<span class="kw">move </span>|connection, ctx| -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
         <span class="comment">// loop through each of the available chunks and append data to a vec.
         </span><span class="kw">let </span><span class="kw-2">mut </span>data: Vec&lt;u8&gt; = <span class="macro">vec!</span>[];

         <span class="kw">loop </span>{
             <span class="kw">let </span>next_chunk = ctx.next_chunk(connection)<span class="question-mark">?</span>;
             <span class="macro">cbreak!</span>(next_chunk.is_none());
             <span class="kw">let </span>next_chunk = next_chunk.unwrap();
             data.extend(next_chunk.data());
         }

         <span class="comment">// convert returned data to a utf8 string
         </span><span class="kw">let </span>dstring = from_utf8(<span class="kw-2">&amp;</span>data)<span class="question-mark">?</span>;
         <span class="macro">info!</span>(<span class="string">"data[{}]='{}'"</span>, connection.id(), dstring)<span class="question-mark">?</span>;

         <span class="comment">// get a write handle
         </span><span class="kw">let </span><span class="kw-2">mut </span>wh = connection.write_handle()<span class="question-mark">?</span>;

         <span class="comment">// echo
         </span>wh.write(dstring.as_bytes())<span class="question-mark">?</span>;

         <span class="comment">// clear all chunks from this connection. Note that partial
         // clearing is possible with the ctx.clear_through function
         // or no data can be cleared at all in which case it can
         // be accessed on a subsequent request. When the connection
         // is closed, all data is cleared automatically.
         </span>ctx.clear_all(connection)<span class="question-mark">?</span>;

         <span class="prelude-val">Ok</span>(())
     })<span class="question-mark">?</span>;

     <span class="comment">// no other handlers are necessary

     </span>evh.start()<span class="question-mark">?</span>;

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>For full details, see <a href="../bmw_evh/index.html" title="mod bmw_evh"><code>bmw_evh</code></a>.</p>
<h2 id="bmw-utility-crate"><a class="doc-anchor" href="#bmw-utility-crate">§</a>BMW Utility crate</h2>
<p>The BMW Utility crate includes utilities used throughout BMW. The <a href="../bmw_util/types/trait.Hashtable.html" title="trait bmw_util::types::Hashtable"><code>bmw_util::Hashtable</code></a>, <a href="../bmw_util/types/trait.Hashset.html" title="trait bmw_util::types::Hashset"><code>bmw_util::Hashset</code></a>,
<a href="../bmw_util/types/trait.List.html" title="trait bmw_util::types::List"><code>bmw_util::List</code></a>, <a href="../bmw_util/types/struct.Array.html" title="struct bmw_util::types::Array"><code>bmw_util::Array</code></a>, <a href="../bmw_util/types/struct.ArrayList.html" title="struct bmw_util::types::ArrayList"><code>bmw_util::ArrayList</code></a>, <a href="../bmw_util/types/trait.Stack.html" title="trait bmw_util::types::Stack"><code>bmw_util::Stack</code></a>, <a href="../bmw_util/types/trait.Queue.html" title="trait bmw_util::types::Queue"><code>bmw_util::Queue</code></a>
data structures are designed to reduce memory allocations after initialization. The
<a href="../bmw_util/macro.lock_box.html" title="macro bmw_util::lock_box"><code>bmw_util::lock_box</code></a> macro is used for locking, the rand module contains
cryptographically secure system random number generators, and <a href="../bmw_util/macro.thread_pool.html" title="macro bmw_util::thread_pool"><code>bmw_util::thread_pool</code></a>
implements a thread pool. For full details on the utility module, see <a href="../bmw_util/index.html" title="mod bmw_util"><code>bmw_util</code></a>.</p>
<h2 id="bmw-configuration-crate"><a class="doc-anchor" href="#bmw-configuration-crate">§</a>BMW Configuration crate</h2>
<p>The BMW Configuration library is used to configure other crates within the BMW project. An
example of how it may be used can be found below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// use all from bmw_conf
 </span><span class="kw">use </span>bmw_conf::<span class="kw-2">*</span>;
 <span class="comment">// use all from bmw_err
 </span><span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// build a config using the bmw_conf::config macro.
     </span><span class="kw">let </span>config = <span class="macro">config!</span>(MaxLoadFactor(<span class="number">0.4</span>), SlabSize(<span class="number">100</span>), SlabCount(<span class="number">200</span>));
     <span class="comment">// check the config based on allowed and required configuration options.
     </span>config.check_config(
         <span class="macro">vec!</span>[
             ConfigOptionName::MaxLoadFactor,
             ConfigOptionName::SlabSize,
             ConfigOptionName::SlabCount,
             ConfigOptionName::AutoRotate
         ],
         <span class="macro">vec!</span>[
             ConfigOptionName::SlabCount
         ]
     )<span class="question-mark">?</span>;

     <span class="comment">// retrieve specified values or use defaults.
     </span><span class="macro">assert_eq!</span>(config.get_or_f64(<span class="kw-2">&amp;</span>ConfigOptionName::MaxLoadFactor, <span class="number">0.5</span>), <span class="number">0.4</span>);
     <span class="macro">assert_eq!</span>(config.get_or_usize(<span class="kw-2">&amp;</span>ConfigOptionName::SlabSize, <span class="number">12</span>), <span class="number">100</span>);
     <span class="macro">assert_eq!</span>(config.get_or_usize(<span class="kw-2">&amp;</span>ConfigOptionName::SlabCount, <span class="number">100</span>), <span class="number">200</span>);
     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Full details of the BMW configuration crate can be found here: [<code>bmw_conf</code>].</p>
<h2 id="bmw-logging-crate"><a class="doc-anchor" href="#bmw-logging-crate">§</a>BMW Logging crate</h2>
<p>The BMW Logging library is used to log data in other crates within the BMW project. An example
of how it may be used can be found below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_test::<span class="kw-2">*</span>;
 <span class="kw">use </span>std::path::PathBuf;

 <span class="macro">info!</span>(); <span class="comment">// set the log level of the global logger to 'info'.

 </span><span class="kw">fn </span>global_logger() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// get test_info for a uniqe test directory
     </span><span class="kw">let </span>test_info = <span class="macro">test_info!</span>()<span class="question-mark">?</span>;

     <span class="comment">// create a path_buf
     </span><span class="kw">let </span><span class="kw-2">mut </span>buf = PathBuf::new();
     buf.push(test_info.directory());
     buf.push(<span class="string">"mylog.log"</span>);

     <span class="comment">// init the log. Important to do this before any logging takes place or a default log
     // config will be applied
     </span><span class="macro">log_init!</span>(
         AutoRotate(<span class="bool-val">true</span>), <span class="comment">// turn on autorotation
         </span>LogFilePath(<span class="prelude-val">Some</span>(buf)), <span class="comment">// log to our log file
         </span>MaxSizeBytes(<span class="number">1024 </span>* <span class="number">1024</span>), <span class="comment">// do a rotation when the log file reaches 1mb
         </span>MaxAgeMillis(<span class="number">60 </span>* <span class="number">60 </span>* <span class="number">1000</span>) <span class="comment">// do a rotation when the log file is over 1 hour old
     </span>)<span class="question-mark">?</span>;

     <span class="comment">// log at the info level
     </span><span class="macro">info!</span>(<span class="string">"Starting up the logger"</span>)<span class="question-mark">?</span>;

     <span class="comment">// log at the debug level
     </span><span class="macro">debug!</span>(<span class="string">"This will not show up because 'debug' is below 'info'"</span>)<span class="question-mark">?</span>;
     <span class="prelude-val">Ok</span>(())
 }

 <span class="comment">// example of an independent logger
 </span><span class="kw">fn </span>independent_logger() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// get a test_info to get a unique test directory
     </span><span class="kw">let </span>test_info = <span class="macro">test_info!</span>()<span class="question-mark">?</span>;

     <span class="comment">// create the path buffer with our log name
     </span><span class="kw">let </span><span class="kw-2">mut </span>buf = PathBuf::new();
     buf.push(test_info.directory());
     buf.push(<span class="string">"some_log.log"</span>);

     <span class="comment">// create the logger with the logger macro.
     </span><span class="kw">let </span><span class="kw-2">mut </span>logger = <span class="macro">logger!</span>(
         LogFilePath(<span class="prelude-val">Some</span>(buf)), <span class="comment">// our path
         </span>MaxAgeMillis(<span class="number">1000 </span>* <span class="number">30 </span>* <span class="number">60</span>), <span class="comment">// log max age before rotation
         </span>DisplayColors(<span class="bool-val">false</span>), <span class="comment">// don't display colors
         </span>DisplayBackTrace(<span class="bool-val">false</span>) <span class="comment">// don't show the backtrace on error/fatal log lines
     </span>)<span class="question-mark">?</span>;

     logger.init()<span class="question-mark">?</span>;
     logger.set_log_level(LogLevel::Debug);
     logger.log(LogLevel::Debug, <span class="string">"this is a test"</span>)<span class="question-mark">?</span>;

     <span class="prelude-val">Ok</span>(())
 }
 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     global_logger()<span class="question-mark">?</span>;
     independent_logger()<span class="question-mark">?</span>;
     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>The default output will look something like this:</p>
<div class="example-wrap"><pre class="language-text"><code> [2022-02-24 13:52:24.123]: (FATAL) [..ibconcord/src/main.rs:116]: fatal
 [2022-02-24 13:52:24.123]: (ERROR) [..ibconcord/src/main.rs:120]: error
 [2022-02-24 13:52:24.123]: (WARN) [..ibconcord/src/main.rs:124]: warn
 [2022-02-24 13:52:24.123]: (INFO) [..ibconcord/src/main.rs:128]: info
 [2022-02-24 13:52:24.123]: (DEBUG) [..ibconcord/src/main.rs:132]: debug
 [2022-02-24 13:52:24.123]: (TRACE) [..ibconcord/src/main.rs:136]: trace
</code></pre></div>
<p>If enabled, color coding is included as well.</p>
<p>Full details of the BMW logging crate can be found here: <a href="../bmw_log/index.html" title="mod bmw_log"><code>bmw_log</code></a>.</p>
<h2 id="bmw-error-crate"><a class="doc-anchor" href="#bmw-error-crate">§</a>BMW Error crate</h2>
<p>The BMW Error crate is used to handle errors in the other BMW crates. The two main useful
macros from this crate are the [<code>bmw_err::err!</code>] macro and the [<code>bmw_err::map_err</code>] macro.</p>
<p>Full details of the BMW logging crate can be found here: [<code>bmw_err</code>].</p>
</div></details></section></div></main></body></html>