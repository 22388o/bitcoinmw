<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The util crate provides the data structures that are used in bmw. The data structures implemented include `crate::Hashtable`, `crate::Hashset`, `crate::List`, `crate::Array`, `crate::ArrayList`, `crate::Stack`, `crate::Queue`, and `crate::SuffixTree`. Additionally a `crate::ThreadPool` implementation is provided. Each data structure can be instantiated in a impl and Box form using the `crate::Builder` or through macros. The impls completely stack based and the box forms are Box&lt;dyn ..&gt;’s that can be stored in other structs and Enums. While the boxed versions do store data on the heap, it is only pointers and the vast majority of the data, in either form, is stored in pre-allocated slabs. The array based structures do use the heap, they use `std::vec::Vec` as the underlying storage mechanism, but they only allocate heap memory when they are created and none afterwords."><title>bmw_util - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bmw_util" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../bmw_util/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../bmw_util/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate bmw_util</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.0.3-beta.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bmw_util</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/bmw_util/lib.rs.html#13-554">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The util crate provides the data structures that are used in bmw. The data structures
implemented include <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a>, <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a>, <a href="trait.List.html" title="trait bmw_util::List"><code>crate::List</code></a>, <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a>,
<a href="struct.ArrayList.html" title="struct bmw_util::ArrayList"><code>crate::ArrayList</code></a>, <a href="trait.Stack.html" title="trait bmw_util::Stack"><code>crate::Stack</code></a>, <a href="trait.Queue.html" title="trait bmw_util::Queue"><code>crate::Queue</code></a>, and <a href="trait.SuffixTree.html" title="trait bmw_util::SuffixTree"><code>crate::SuffixTree</code></a>. Additionally
a <a href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool"><code>crate::ThreadPool</code></a> implementation is provided. Each data structure can be instantiated in
a impl and Box form using the <a href="struct.Builder.html" title="struct bmw_util::Builder"><code>crate::Builder</code></a> or through macros. The impls completely stack
based and the box forms are Box&lt;dyn ..&gt;’s that can be stored in other structs and Enums. While
the boxed versions do store data on the heap, it is only pointers and the vast majority of the
data, in either form, is stored in pre-allocated slabs. The array based structures do use
the heap, they use <a href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>std::vec::Vec</code></a> as the underlying storage mechanism, but they only allocate
heap memory when they are created and none afterwords.</p>
<h2 id="motivation"><a href="#motivation">Motivation</a></h2>
<p>The advantage of these implementations is that they do not allocate memory on the
heap after initialization of the data structure. So, we can create a <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a>,
<a href="trait.List.html" title="trait bmw_util::List"><code>crate::List</code></a> or a <a href="macro.hashset.html" title="macro bmw_util::hashset"><code>crate::hashset</code></a> and once created, do millions of operations and
no heap memory will be allocated or deallocated. Dynamic heap allocations that are long-lived can cause
substantial problems like slowness and memory fragmentation and even system crashes and these data structures
are intended to alleviate those problems. The <a href="https://doc.rust-lang.org/1.73.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop"><code>core::ops::Drop</code></a> trait is also implemented so all
slabs used by the data structure are freed when the data structure goes out of scope.</p>
<h2 id="performance"><a href="#performance">Performance</a></h2>
<p>The hashtable/set are not as fast as the native Rust data structures because they
require serialization and deserialization of the entries on each operation. However, the
performance is at least in the ballpark of the standard data structures. The array, arraylist,
queue, and stack are faster for insert, slower for initialization and about the same for
iteration and drop. A performance tool is included in the project in the etc directory
<a href="https://github.com/37miners/bmw/tree/main/etc/ds_perf">ds_perf</a>.</p>
<p>Below is the output of some runs on a linux machine.</p>
<div class="example-wrap"><pre class="language-text"><code> $ ./target/release/perf  --help
 ds_perf 1.0
 37 Miners, LLC

 USAGE:
    perf [FLAGS]

 FLAGS:
     --array           run tests for array
     --array_string    run tests for array with strings
     --arraylist       run tests for array list
     --hashmap         run tests for standard rust library hashmap
     --hashtable       run tests for hashtable
 -h, --help            Prints help information
 -V, --version         Prints version information
     --vec             run tests for standard rust library vec
     --vec_string      run tests for vec with strings

 $ ./target/release/perf  --array_string
 [2022-09-01 13:02:41.974]: Starting ds_perf
 [2022-09-01 13:02:41.974]: Testing array string
 [2022-09-01 13:02:41.974]: array init: alloc: 240,000, dealloc: 0, alloc_qty: 1, dealloc_qty: 0, delta: 240,000, elapsed: 180.336µs
 [2022-09-01 13:02:41.975]: array insert: alloc: 110,000, dealloc: 0, alloc_qty: 10,000, dealloc_qty: 0, delta: 110,000, elapsed: 332.891µs
 [2022-09-01 13:02:41.975]: array iter: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 27ns
 [2022-09-01 13:02:41.975]: array drop: alloc: 0, dealloc: 350,000, alloc_qty: 0, dealloc_qty: 10,001, delta: -350,000, elapsed: 121.148µs

 $ ./target/release/perf  --vec_string
 [2022-09-01 13:02:38.151]: Starting ds_perf
 [2022-09-01 13:02:38.151]: Testing vec string
 [2022-09-01 13:02:38.151]: vec init: alloc: 240,000, dealloc: 0, alloc_qty: 1, dealloc_qty: 0, delta: 240,000, elapsed: 177.351µs
 [2022-09-01 13:02:38.151]: vec insert: alloc: 110,000, dealloc: 0, alloc_qty: 10,000, dealloc_qty: 0, delta: 110,000, elapsed: 324.671µs
 [2022-09-01 13:02:38.151]: vec iter: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 40ns
 [2022-09-01 13:02:38.152]: vec drop: alloc: 0, dealloc: 350,000, alloc_qty: 0, dealloc_qty: 10,001, delta: -350,000, elapsed: 121.868µs

 $ ./target/release/perf  --array
 [2022-09-01 13:00:22.190]: Starting ds_perf
 [2022-09-01 13:00:22.190]: Testing array
 [2022-09-01 13:00:22.190]: array init: alloc: 40,000, dealloc: 0, alloc_qty: 1, dealloc_qty: 0, delta: 40,000, elapsed: 27.454µs
 [2022-09-01 13:00:22.190]: array insert: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 999ns
 [2022-09-01 13:00:22.190]: array iter: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 29ns
 [2022-09-01 13:00:22.190]: array drop: alloc: 0, dealloc: 40,000, alloc_qty: 0, dealloc_qty: 1, delta: -40,000, elapsed: 121ns

 $ ./target/release/perf  --vec
 [2022-09-01 13:00:27.820]: Starting ds_perf
 [2022-09-01 13:00:27.820]: testing vec
 [2022-09-01 13:00:27.820]: vec init: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 120ns
 [2022-09-01 13:00:27.820]: vec insert: alloc: 131,056, dealloc: 65,520, alloc_qty: 13, dealloc_qty: 12, delta: 65,536, elapsed: 48.554µs
 [2022-09-01 13:00:27.820]: vec iter: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 29ns
 [2022-09-01 13:00:27.820]: vec drop: alloc: 0, dealloc: 65,536, alloc_qty: 0, dealloc_qty: 1, delta: -65,536, elapsed: 5.096µs

 $ ./target/release/perf  --hashtable
 [2022-09-01 13:07:30.861]: Starting ds_perf
 [2022-09-01 13:07:30.861]: Testing hashtable
 [2022-09-01 13:07:30.861]: hashtable init: alloc: 100,096, dealloc: 96, alloc_qty: 2, dealloc_qty: 1, delta: 100,000, elapsed: 55.208µs
 [2022-09-01 13:07:30.863]: hashtable insert: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 2.296961ms
 [2022-09-01 13:07:30.865]: hashtable get: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 1.462402ms
 [2022-09-01 13:07:30.865]: hashtable drop: alloc: 100,000, dealloc: 200,000, alloc_qty: 1, dealloc_qty: 2, delta: -100,000, elapsed: 512.423µs

 $ ./target/release/perf  --hashmap
 [2022-09-01 13:07:39.269]: Starting ds_perf
 [2022-09-01 13:07:39.269]: Testing hashmap
 [2022-09-01 13:07:39.269]: hashmap init: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 69ns
 [2022-09-01 13:07:39.270]: hashmap insert: alloc: 688,252, dealloc: 344,172, alloc_qty: 26, dealloc_qty: 24, delta: 344,080, elapsed: 611.785µs
 [2022-09-01 13:07:39.270]: hashmap get: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 199.428µs
 [2022-09-01 13:07:39.270]: hashmap drop: alloc: 0, dealloc: 344,080, alloc_qty: 0, dealloc_qty: 2, delta: -344,080, elapsed: 25.252µs

 $ ./target/release/perf  --arraylist
 [2022-09-01 13:08:08.434]: Starting ds_perf
 [2022-09-01 13:08:08.435]: testing arraylist
 [2022-09-01 13:08:08.435]: arraylist init: alloc: 40,000, dealloc: 0, alloc_qty: 1, dealloc_qty: 0, delta: 40,000, elapsed: 27.827µs
 [2022-09-01 13:08:08.435]: arraylist insert: alloc: 0, dealloc: 0, alloc_qty: 0, dealloc_qty: 0, delta: 0, elapsed: 18.963µs
 [2022-09-01 13:08:08.435]: arraylist iter: alloc: 24, dealloc: 24, alloc_qty: 1, dealloc_qty: 1, delta: 0, elapsed: 20.341µs
 [2022-09-01 13:08:08.435]: arraylist drop: alloc: 1,856, dealloc: 41,856, alloc_qty: 27, dealloc_qty: 28, delta: -40,000, elapsed: 110ns


</code></pre></div>
<p>So, as seen, the performance is somewhat comparable and keep in mind, that these operations are
being done in the sub millisecond time frame, so it’s very unlikely that this will ultimately
impact the performance of the application unless it’s an already very optimized application
that needs to be very scalable.</p>
<h2 id="using-bmw_util-and-other-crates-in-your-project"><a href="#using-bmw_util-and-other-crates-in-your-project">Using bmw_util (and other crates) in your project</a></h2>
<p>To use the crates in bmw in your project, add the following to your Cargo.toml:</p>
<div class="example-wrap"><pre class="language-text"><code> bmw_util   = { git = &quot;https://github.com/37miners/bmw&quot;  }
</code></pre></div>
<p>Optionally, you may wish to use the other associated crates:</p>
<div class="example-wrap"><pre class="language-text"><code> bmw_err    = { git = &quot;https://github.com/37miners/bmw&quot;  }
 bmw_log    = { git = &quot;https://github.com/37miners/bmw&quot;  }
 bmw_derive = { git = &quot;https://github.com/37miners/bmw&quot;  }
</code></pre></div>
<p>The linux dependencies can be installed with the following commands on ubuntu:</p>
<div class="example-wrap"><pre class="language-text"><code> $ sudo apt-get update -yqq
 $ sudo apt-get install -yqq --no-install-recommends libncursesw5-dev libssl-dev
</code></pre></div>
<p>The macos dependencies can be installed with the following commands</p>
<div class="example-wrap"><pre class="language-text"><code>$ brew install llvm
</code></pre></div>
<p>The windows dependencies can be installed with the following commands</p>
<div class="example-wrap"><pre class="language-text"><code>$ choco install -y llvm
</code></pre></div>
<p>BitcoinMW is tested with the latest version of rust. Please ensure to update it.</p>
<h2 id="use-cases"><a href="#use-cases">Use cases</a></h2>
<p>The main use case for these data structures is in server applications to avoid making dynamic
heap allocations at runtime, but they also offer some other interesting properties. For instance, with
the standard rust collections, the entries in the hashmap are just references so they must
stay in scope while they are in the hashmap. With this implementation, that is not required.
The inserted items can be dropped and they will remain in the hashtable/hashset. Also,
<a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> and <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a> both implement the
<a href="trait.Serializable.html" title="trait bmw_util::Serializable"><code>bmw_ser::Serializable</code></a> trait so they can be sent from one part of an app to another or even
sent over the network.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Use of the slab allocator, hashtable, and hashset via macros.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="macro">info!</span>();

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create a slab allocator to be used by our data structures
     </span><span class="kw">let </span>slabs = <span class="macro">slab_allocator!</span>(SlabSize(<span class="number">128</span>), SlabCount(<span class="number">15_000</span>))<span class="question-mark">?</span>;

     <span class="comment">// instantiate a hashtable with specified MaxEntries and MaxLoadFactor
     </span><span class="kw">let </span><span class="kw-2">mut </span>hashtable = <span class="macro">hashtable!</span>(MaxEntries(<span class="number">10_000</span>), MaxLoadFactor(<span class="number">0.85</span>), Slabs(<span class="kw-2">&amp;</span>slabs))<span class="question-mark">?</span>;

     <span class="comment">// insert a key/value pair (rust figures out the data types)
     </span>hashtable.insert(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="number">2</span>)<span class="question-mark">?</span>;

     <span class="comment">// get the value for our key and assert it is correct
     </span><span class="kw">let </span>v = hashtable.get(<span class="kw-2">&amp;</span><span class="number">1</span>)<span class="question-mark">?</span>;
     <span class="macro">assert_eq!</span>(v, <span class="prelude-val">Some</span>(<span class="number">2</span>));
     <span class="macro">info!</span>(<span class="string">&quot;value = {:?}&quot;</span>, v)<span class="question-mark">?</span>;

     <span class="comment">// instantiate a hashset that uses the same slab allocator. Since we don&#39;t specify
     // the MaxLoadFactor, the default value of 0.8 will be used for this hashset.
     </span><span class="kw">let </span><span class="kw-2">mut </span>hashset = <span class="macro">hashset!</span>(MaxEntries(<span class="number">5_000</span>), Slabs(<span class="kw-2">&amp;</span>slabs))<span class="question-mark">?</span>;

     <span class="comment">// insert a key
     </span>hashset.insert(<span class="kw-2">&amp;</span><span class="string">&quot;test&quot;</span>.to_string())<span class="question-mark">?</span>;

     <span class="comment">// assert that our key is found in the hashset
     </span><span class="macro">assert!</span>(hashset.contains(<span class="kw-2">&amp;</span><span class="string">&quot;test&quot;</span>.to_string())<span class="question-mark">?</span>);

     <span class="comment">// do a negative assertion
     </span><span class="macro">assert!</span>(!hashset.contains(<span class="kw-2">&amp;</span><span class="string">&quot;test2&quot;</span>.to_string())<span class="question-mark">?</span>);

     <span class="macro">info!</span>(<span class="string">&quot;complete!&quot;</span>)<span class="question-mark">?</span>;

     <span class="prelude-val">Ok</span>(())
 }
</code></pre></div>
<p>Use of Sortable lists</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// for this example we will use the global slab allocator which is a
     // thread local slab allocator which we can configure via macro
     </span><span class="macro">global_slab_allocator!</span>(SlabSize(<span class="number">64</span>), SlabCount(<span class="number">100_000</span>))<span class="question-mark">?</span>;

     <span class="comment">// create two lists (one linked and one array list).
     // Note that all lists created via macro are interoperable.
     </span><span class="kw">let </span><span class="kw-2">mut </span>list1 = <span class="macro">list!</span>[<span class="number">1u32</span>, <span class="number">2u32</span>, <span class="number">4u32</span>, <span class="number">5u32</span>];
     <span class="kw">let </span><span class="kw-2">mut </span>list2 = <span class="macro">array_list!</span>(<span class="number">10</span>, <span class="kw-2">&amp;</span><span class="number">0u32</span>)<span class="question-mark">?</span>;
     list2.push(<span class="number">5</span>)<span class="question-mark">?</span>;
     list2.push(<span class="number">2</span>)<span class="question-mark">?</span>;
     list2.push(<span class="number">4</span>)<span class="question-mark">?</span>;
     list2.push(<span class="number">1</span>)<span class="question-mark">?</span>;

     <span class="comment">// sort the array list and assert it&#39;s equal to the other list
     </span>list2.sort()<span class="question-mark">?</span>;
     <span class="macro">assert!</span>(<span class="macro">list_eq!</span>(list1, list2));

     <span class="comment">// append list2 to list1 and assert the value
     </span><span class="macro">list_append!</span>(list1, list2);
     <span class="macro">assert!</span>(<span class="macro">list_eq!</span>(list1, <span class="macro">list!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]));

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Arrays</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// instantiate an array of size 100 with the default values of 0usize
     </span><span class="kw">let </span><span class="kw-2">mut </span>arr = <span class="macro">array!</span>(<span class="number">100</span>, <span class="kw-2">&amp;</span><span class="number">0usize</span>)<span class="question-mark">?</span>;

     <span class="comment">// set the 10th element to 1
     </span>arr[<span class="number">10</span>] = <span class="number">1</span>;

     <span class="comment">// set each item to the value of the iterator
     </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">100 </span>{
         arr[i] = i;
     }

     <span class="comment">// assert the values
     </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">100 </span>{
         <span class="macro">assert_eq!</span>(arr[i], i);
     }

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Thread pool and Locks</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create a thread pool with the default settings
     </span><span class="kw">let </span><span class="kw-2">mut </span>tp = <span class="macro">thread_pool!</span>()<span class="question-mark">?</span>;
     tp.set_on_panic(<span class="kw">move </span>|_id,_e| -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; { <span class="prelude-val">Ok</span>(()) })<span class="question-mark">?</span>;

     <span class="comment">// create a lock initializing it&#39;s value to 0
     </span><span class="kw">let </span>x = <span class="macro">lock!</span>(<span class="number">0</span>)<span class="question-mark">?</span>;
     <span class="comment">// clone the lock (one for the thread pool, one for the local thread)
     </span><span class="kw">let </span><span class="kw-2">mut </span>x_clone = x.clone();

     <span class="comment">// execute in the thread pool
     </span><span class="kw">let </span>handle = <span class="macro">execute!</span>(tp, {
         <span class="comment">// obtain the write lock for x
         </span><span class="kw">let </span><span class="kw-2">mut </span>x = x_clone.wlock()<span class="question-mark">?</span>;
         <span class="comment">// set the value to 1
         </span>(<span class="kw-2">**</span>x.guard()) = <span class="number">1</span>;

         <span class="comment">// return the value of 100
         </span><span class="prelude-val">Ok</span>(<span class="number">100</span>)
     })<span class="question-mark">?</span>;

     <span class="comment">// block on the thread and assert the value returned is 100
     </span><span class="macro">assert_eq!</span>(<span class="macro">block_on!</span>(handle), PoolResult::Ok(<span class="number">100</span>));

     <span class="comment">// obtain the read lock for x
     </span><span class="kw">let </span>x = x.rlock()<span class="question-mark">?</span>;
     <span class="comment">// assert the value of x is now 1
     </span><span class="macro">assert_eq!</span>(<span class="kw-2">**</span>x.guard(), <span class="number">1</span>);

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Boxed and Sync versions</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">struct </span>MyStruct {
     hashtable: Box&lt;<span class="kw">dyn </span>Hashtable&lt;u32, String&gt;&gt;,
 }

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create a slab allocator to be used by our data structures
     </span><span class="kw">let </span>slabs = <span class="macro">slab_allocator!</span>(SlabSize(<span class="number">128</span>), SlabCount(<span class="number">15_000</span>))<span class="question-mark">?</span>;

     {
     
         <span class="comment">// instantiate a hashtable with specified MaxEntries and MaxLoadFactor
         </span><span class="kw">let </span>hashtable = <span class="macro">hashtable_box!</span>(
             MaxEntries(<span class="number">10_000</span>),
             MaxLoadFactor(<span class="number">0.85</span>),
             Slabs(<span class="kw-2">&amp;</span>slabs)
         )<span class="question-mark">?</span>;

         <span class="kw">let </span><span class="kw-2">mut </span>s = MyStruct {
             hashtable,
         };

         s.hashtable.insert(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="string">&quot;something&quot;</span>.to_string())<span class="question-mark">?</span>;
         s.hashtable.insert(<span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="string">&quot;something else&quot;</span>.to_string())<span class="question-mark">?</span>;

         <span class="macro">assert_eq!</span>(s.hashtable.get(<span class="kw-2">&amp;</span><span class="number">1</span>)<span class="question-mark">?</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;something&quot;</span>.to_string()));

     }


     <span class="comment">// sync hashtable with default configuration
     </span><span class="kw">let </span><span class="kw-2">mut </span>hashtable2 = <span class="macro">hashtable_sync!</span>()<span class="question-mark">?</span>;
     hashtable2.insert(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span><span class="number">10</span>)<span class="question-mark">?</span>;
     hashtable2.insert(<span class="kw-2">&amp;</span><span class="number">2</span>, <span class="kw-2">&amp;</span><span class="number">20</span>)<span class="question-mark">?</span>;

     <span class="comment">// create a thread pool with the default settings
     </span><span class="kw">let </span><span class="kw-2">mut </span>tp = <span class="macro">thread_pool!</span>()<span class="question-mark">?</span>;
     tp.set_on_panic(<span class="kw">move </span>|_id,_e| -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; { <span class="prelude-val">Ok</span>(()) })<span class="question-mark">?</span>;

     <span class="comment">// put the hashtable into a lock and clone it
     </span><span class="kw">let </span><span class="kw-2">mut </span>lock = <span class="macro">lock!</span>(hashtable2)<span class="question-mark">?</span>;
     <span class="kw">let </span>lock_clone = lock.clone();

     <span class="comment">// execute a task in the thread pool
     </span><span class="kw">let </span>handle = <span class="macro">execute!</span>(tp, {
         <span class="comment">// obtain the write lock to the hashtable and insert an additional value
         </span><span class="kw">let </span><span class="kw-2">mut </span>hashtable2 = lock.wlock()<span class="question-mark">?</span>;
         (<span class="kw-2">**</span>hashtable2.guard()).insert(<span class="kw-2">&amp;</span><span class="number">3</span>, <span class="kw-2">&amp;</span><span class="number">30</span>)<span class="question-mark">?</span>;
         <span class="prelude-val">Ok</span>(())
     })<span class="question-mark">?</span>;

     <span class="comment">// block on the task that is in the thread pool
     </span><span class="macro">block_on!</span>(handle);

     <span class="comment">// obtain the read lock and assert all three values are in the hashtable
     </span><span class="kw">let </span>hashtable2 = lock_clone.rlock()<span class="question-mark">?</span>;
     <span class="macro">assert_eq!</span>((<span class="kw-2">**</span>hashtable2.guard()).get(<span class="kw-2">&amp;</span><span class="number">1</span>)<span class="question-mark">?</span>, <span class="prelude-val">Some</span>(<span class="number">10</span>));
     <span class="macro">assert_eq!</span>((<span class="kw-2">**</span>hashtable2.guard()).get(<span class="kw-2">&amp;</span><span class="number">2</span>)<span class="question-mark">?</span>, <span class="prelude-val">Some</span>(<span class="number">20</span>));
     <span class="macro">assert_eq!</span>((<span class="kw-2">**</span>hashtable2.guard()).get(<span class="kw-2">&amp;</span><span class="number">3</span>)<span class="question-mark">?</span>, <span class="prelude-val">Some</span>(<span class="number">30</span>));


     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Suffix Tree</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create an array of matches for the suffix tree to populate in tmatch
     </span><span class="kw">let </span><span class="kw-2">mut </span>matches = [Builder::build_match_default(); <span class="number">10</span>];


     <span class="comment">// create a suffix tree with two patterns with distinct Regexes and Ids
     // Setting a termination length (length to stop processing the text) of 100
     // and a max wild card length (the maximum length of any wildcards) of 50
     </span><span class="kw">let </span><span class="kw-2">mut </span>suffix_tree = <span class="macro">suffix_tree!</span>(
         <span class="macro">list!</span>[
             <span class="macro">pattern!</span>(Regex(<span class="string">&quot;abc&quot;</span>), Id(<span class="number">0</span>))<span class="question-mark">?</span>,
             <span class="macro">pattern!</span>(Regex(<span class="string">&quot;def.*ok&quot;</span>), Id(<span class="number">1</span>))<span class="question-mark">?
         </span>],
         TerminationLength(<span class="number">100</span>),
         MaxWildcardLength(<span class="number">50</span>)
     )<span class="question-mark">?</span>;

     <span class="comment">// run the matches and return the number of matches assert that it&#39;s
     // one for the abc match
     </span><span class="kw">let </span>match_count = suffix_tree.tmatch(<span class="string">b&quot;abc&quot;</span>, <span class="kw-2">&amp;mut </span>matches)<span class="question-mark">?</span>;
     <span class="macro">assert_eq!</span>(match_count, <span class="number">1</span>);

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Queues and Stacks</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="comment">// create a stack and a queue both with capacity of 1_000 items and &amp;0
     // is the default value used to initialize the array
     </span><span class="kw">let </span><span class="kw-2">mut </span>queue = <span class="macro">queue!</span>(<span class="number">1_000</span>, <span class="kw-2">&amp;</span><span class="number">0</span>)<span class="question-mark">?</span>;
     <span class="kw">let </span><span class="kw-2">mut </span>stack = <span class="macro">stack!</span>(<span class="number">1_000</span>, <span class="kw-2">&amp;</span><span class="number">0</span>)<span class="question-mark">?</span>;

     <span class="comment">// add three items to the queue
     </span>queue.enqueue(<span class="number">1</span>)<span class="question-mark">?</span>;
     queue.enqueue(<span class="number">2</span>)<span class="question-mark">?</span>;
     queue.enqueue(<span class="number">3</span>)<span class="question-mark">?</span>;

     <span class="comment">// add the same three items to the stack
     </span>stack.push(<span class="number">1</span>)<span class="question-mark">?</span>;
     stack.push(<span class="number">2</span>)<span class="question-mark">?</span>;
     stack.push(<span class="number">3</span>)<span class="question-mark">?</span>;

     <span class="comment">// dequeue/pop and assert that the queue/stack are appropriately returning the items
     </span><span class="macro">assert_eq!</span>(queue.dequeue(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
     <span class="macro">assert_eq!</span>(stack.pop(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));

     <span class="comment">// dequeue/pop and assert that the queue/stack are appropriately returning the items
     </span><span class="macro">assert_eq!</span>(queue.dequeue(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));
     <span class="macro">assert_eq!</span>(stack.pop(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));

     <span class="comment">// peek at both the stack and queue (view value, but do not remove it from the queue)
     </span><span class="macro">assert_eq!</span>(queue.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));
     <span class="macro">assert_eq!</span>(stack.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));

     <span class="comment">// dequeue/pop the last item
     </span><span class="macro">assert_eq!</span>(queue.dequeue(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">3</span>));
     <span class="macro">assert_eq!</span>(stack.pop(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));

     <span class="comment">// assert that the queue/stack are empty
     </span><span class="macro">assert_eq!</span>(queue.dequeue(), <span class="prelude-val">None</span>);
     <span class="macro">assert_eq!</span>(stack.pop(), <span class="prelude-val">None</span>);

     <span class="prelude-val">Ok</span>(())
 }</code></pre></div>
<p>Derive Serializable trait</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// import the util/log/err libraries
 </span><span class="kw">use </span>bmw_util::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_log::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_err::<span class="kw-2">*</span>;
 <span class="kw">use </span>bmw_derive::<span class="kw-2">*</span>;

 <span class="macro">info!</span>();

 <span class="attr">#[derive(Serializable, Clone, Debug, PartialEq)]
 </span><span class="kw">struct </span>MyStruct {
     id: u128,
     name: String,
     phone: <span class="prelude-ty">Option</span>&lt;String&gt;,
     age: u8,
 }

 <span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
     <span class="kw">let </span>s = MyStruct {
         id: <span class="number">1234</span>,
         name: <span class="string">&quot;Hagrid&quot;</span>.to_string(),
         phone: <span class="prelude-val">None</span>,
         age: <span class="number">54</span>,
     };

     <span class="macro">debug!</span>(<span class="string">&quot;my struct = {:?}&quot;</span>, s)<span class="question-mark">?</span>;

     <span class="kw">let </span><span class="kw-2">mut </span>hashtable = <span class="macro">hashtable!</span>()<span class="question-mark">?</span>;

     hashtable.insert(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="kw-2">&amp;</span>s)<span class="question-mark">?</span>;

     <span class="kw">let </span>v = hashtable.get(<span class="kw-2">&amp;</span><span class="number">1</span>)<span class="question-mark">?</span>;
     <span class="macro">assert_eq!</span>(v, <span class="prelude-val">Some</span>(s));

     <span class="macro">info!</span>(<span class="string">&quot;value of record #1 is {:?}&quot;</span>, v)<span class="question-mark">?</span>;
     
     <span class="prelude-val">Ok</span>(())
 }
</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.GLOBAL_SLAB_ALLOCATOR"><code>pub use crate::slabs::GLOBAL_SLAB_ALLOCATOR;</code></div></li><li><div class="item-name"><code>pub use crate::types::<a class="enum" href="enum.ConfigOption.html" title="enum bmw_util::ConfigOption">ConfigOption</a>::*;</code></div></li><li><div class="item-name"><code>pub use crate::types::<a class="enum" href="enum.PatternParam.html" title="enum bmw_util::PatternParam">PatternParam</a>::*;</code></div></li><li><div class="item-name"><code>pub use crate::types::<a class="enum" href="enum.SuffixParam.html" title="enum bmw_util::SuffixParam">SuffixParam</a>::*;</code></div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.array.html" title="macro bmw_util::array">array</a></div><div class="desc docblock-short">The <a href="macro.array.html" title="macro bmw_util::array"><code>crate::array!</code></a> macro builds an <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a>. The macro takes the following
parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.array_list.html" title="macro bmw_util::array_list">array_list</a></div><div class="desc docblock-short">The <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a> macro builds an <a href="struct.ArrayList.html" title="struct bmw_util::ArrayList"><code>crate::ArrayList</code></a> in the form of a impl
SortableList. The macro takes the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.array_list_box.html" title="macro bmw_util::array_list_box">array_list_box</a></div><div class="desc docblock-short">This macro is identical to <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a> except that the value is returned in a box.
To be exact, the return value is <code>Box&lt;dyn SortableList&gt;</code>. The boxed version can then be used to
store in structs and enums. See <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a> for more details and an example.</div></li><li><div class="item-name"><a class="macro" href="macro.array_list_sync.html" title="macro bmw_util::array_list_sync">array_list_sync</a></div><div class="desc docblock-short">sync version of <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.array_list_sync_box.html" title="macro bmw_util::array_list_sync_box">array_list_sync_box</a></div><div class="desc docblock-short">sync box version of <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.block_on.html" title="macro bmw_util::block_on">block_on</a></div><div class="desc docblock-short">Macro used to block until a thread pool has completed the task. See <a href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool"><code>crate::ThreadPool</code></a> for working examples.</div></li><li><div class="item-name"><a class="macro" href="macro.execute.html" title="macro bmw_util::execute">execute</a></div><div class="desc docblock-short">Macro used to execute tasks in a thread pool. See <a href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool"><code>crate::ThreadPool</code></a> for working examples.</div></li><li><div class="item-name"><a class="macro" href="macro.global_slab_allocator.html" title="macro bmw_util::global_slab_allocator">global_slab_allocator</a></div><div class="desc docblock-short">The <code>global_slab_allocator</code> macro initializes the global thread local slab allocator
for the thread that it is executed in. It takes the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.hashset.html" title="macro bmw_util::hashset">hashset</a></div><div class="desc docblock-short">The <a href="macro.hashset.html" title="macro bmw_util::hashset"><code>crate::hashset</code></a> macro builds a <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a> with the specified configuration and
optionally the specified <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a>. The macro accepts the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.hashset_box.html" title="macro bmw_util::hashset_box">hashset_box</a></div><div class="desc docblock-short">The <a href="macro.hashset_box.html" title="macro bmw_util::hashset_box"><code>crate::hashset_box</code></a> macro is the same as the <a href="macro.hashset.html" title="macro bmw_util::hashset"><code>crate::hashset</code></a> macro except that the
hashset is returned in a box. See <a href="macro.hashset.html" title="macro bmw_util::hashset"><code>crate::hashset</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.hashset_sync.html" title="macro bmw_util::hashset_sync">hashset_sync</a></div><div class="desc docblock-short">The hashset_sync macro is the same as <a href="macro.hashset.html" title="macro bmw_util::hashset"><code>crate::hashset</code></a> except that the returned Hashset
implements Send and Sync and can be safely passed through threads. See
<a href="macro.hashtable_sync.html" title="macro bmw_util::hashtable_sync"><code>crate::hashtable_sync</code></a> for further details.</div></li><li><div class="item-name"><a class="macro" href="macro.hashset_sync_box.html" title="macro bmw_util::hashset_sync_box">hashset_sync_box</a></div><div class="desc docblock-short">The hashset_sync_box macro is the boxed version of the <a href="macro.hashset_sync.html" title="macro bmw_util::hashset_sync"><code>crate::hashset_sync</code></a> macro. It is the
same except that the returned <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a> is in a Box so it can be added to structs and
enums.</div></li><li><div class="item-name"><a class="macro" href="macro.hashtable.html" title="macro bmw_util::hashtable">hashtable</a></div><div class="desc docblock-short">The <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a> macro builds a <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> with the specified configuration and
optionally the specified <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a>. The macro accepts the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.hashtable_box.html" title="macro bmw_util::hashtable_box">hashtable_box</a></div><div class="desc docblock-short">The <a href="macro.hashtable_box.html" title="macro bmw_util::hashtable_box"><code>crate::hashtable_box</code></a> macro builds a <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> with the specified configuration and
optionally the specified <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a>. The only difference between this macro and
the <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a> macro is that the returned hashtable is inserted into a Box.
Specifically, the return type is a <code>Box&lt;dyn Hashtable&gt;</code>. See <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a> for further
details.</div></li><li><div class="item-name"><a class="macro" href="macro.hashtable_sync.html" title="macro bmw_util::hashtable_sync">hashtable_sync</a></div><div class="desc docblock-short">The difference between this macro and the <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a> macro is that the returned
<a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> implements the Send and Sync traits and is thread safe. With this
hashtable you cannot specify a <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a> because they use <a href="https://doc.rust-lang.org/1.73.0/core/cell/struct.RefCell.html" title="struct core::cell::RefCell"><code>std::cell::RefCell</code></a>
which is not thread safe. That is also why this macro returns an error if
<a href="enum.ConfigOption.html#variant.Slabs" title="variant bmw_util::ConfigOption::Slabs"><code>crate::ConfigOption::Slabs</code></a> is specified. The parameters for this macro are:</div></li><li><div class="item-name"><a class="macro" href="macro.hashtable_sync_box.html" title="macro bmw_util::hashtable_sync_box">hashtable_sync_box</a></div><div class="desc docblock-short">This macro is the same as <a href="macro.hashtable_sync.html" title="macro bmw_util::hashtable_sync"><code>hashtable_sync</code></a> except that the returned hashtable is in a Box.
This macro can be used if the sync hashtable needs to be placed in a struct or an enum.
See <a href="macro.hashtable.html" title="macro bmw_util::hashtable"><code>crate::hashtable</code></a> and <a href="macro.hashtable_sync.html" title="macro bmw_util::hashtable_sync"><code>crate::hashtable_sync</code></a> for further details.</div></li><li><div class="item-name"><a class="macro" href="macro.list.html" title="macro bmw_util::list">list</a></div><div class="desc docblock-short">The list macro is used to create lists. This macro uses the global slab allocator. To use a
specified slab allocator, see <a href="struct.Builder.html#method.build_list" title="associated function bmw_util::Builder::build_list"><code>crate::Builder::build_list</code></a>. It has the same syntax as the
<a href="https://doc.rust-lang.org/1.73.0/alloc/macro.vec.html" title="macro alloc::vec"><code>std::vec!</code></a> macro. Note that this macro and the builder function both
return an implementation of the <a href="trait.SortableList.html" title="trait bmw_util::SortableList"><code>crate::SortableList</code></a> trait.</div></li><li><div class="item-name"><a class="macro" href="macro.list_append.html" title="macro bmw_util::list_append">list_append</a></div><div class="desc docblock-short">Append list2 to list1.</div></li><li><div class="item-name"><a class="macro" href="macro.list_box.html" title="macro bmw_util::list_box">list_box</a></div><div class="desc docblock-short">This is the boxed version of list. The returned value is <code>Box&lt;dyn SortableList&gt;</code>. Otherwise,
this macro is identical to <a href="macro.list.html" title="macro bmw_util::list"><code>crate::list</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.list_eq.html" title="macro bmw_util::list_eq">list_eq</a></div><div class="desc docblock-short">Compares equality of list1 and list2.</div></li><li><div class="item-name"><a class="macro" href="macro.list_sync.html" title="macro bmw_util::list_sync">list_sync</a></div><div class="desc docblock-short">Like <a href="macro.hashtable_sync.html" title="macro bmw_util::hashtable_sync"><code>crate::hashtable_sync</code></a> and <a href="macro.hashset_sync.html" title="macro bmw_util::hashset_sync"><code>crate::hashset_sync</code></a> list has a ‘sync’ version. See those
macros for more details and see the <a href="index.html" title="mod bmw_util"><code>crate</code></a> for an example of the sync version of a hashtable.
Just as in that example the list can be put into a <a href="macro.lock.html" title="macro bmw_util::lock"><code>crate::lock!</code></a> or <a href="macro.lock_box.html" title="macro bmw_util::lock_box"><code>crate::lock_box</code></a>
and passed between threads.</div></li><li><div class="item-name"><a class="macro" href="macro.list_sync_box.html" title="macro bmw_util::list_sync_box">list_sync_box</a></div><div class="desc docblock-short">Box version of the <a href="macro.list_sync.html" title="macro bmw_util::list_sync"><code>crate::list_sync</code></a> macro.</div></li><li><div class="item-name"><a class="macro" href="macro.lock.html" title="macro bmw_util::lock">lock</a></div><div class="desc docblock-short">Macro to get a <a href="trait.Lock.html" title="trait bmw_util::Lock"><code>crate::Lock</code></a>. Internally, the parameter passed in is wrapped in
an Arc&lt;Rwlock<T>&gt; wrapper that can be used to obtain read/write locks around any
data structure.</div></li><li><div class="item-name"><a class="macro" href="macro.lock_box.html" title="macro bmw_util::lock_box">lock_box</a></div><div class="desc docblock-short">The same as lock except that the value returned is in a Box&lt;dyn LockBox<T>&gt; structure.
See <a href="trait.LockBox.html" title="trait bmw_util::LockBox"><code>crate::LockBox</code></a> for a working example.</div></li><li><div class="item-name"><a class="macro" href="macro.pattern.html" title="macro bmw_util::pattern">pattern</a></div><div class="desc docblock-short">The pattern macro builds a <a href="struct.Pattern.html" title="struct bmw_util::Pattern"><code>crate::Pattern</code></a> which is used by the <a href="trait.SuffixTree.html" title="trait bmw_util::SuffixTree"><code>crate::SuffixTree</code></a>.
The pattern macro takes the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.queue.html" title="macro bmw_util::queue">queue</a></div><div class="desc docblock-short">This macro creates a <a href="trait.Queue.html" title="trait bmw_util::Queue"><code>crate::Queue</code></a>. The parameters are</div></li><li><div class="item-name"><a class="macro" href="macro.queue_box.html" title="macro bmw_util::queue_box">queue_box</a></div><div class="desc docblock-short">This is the box version of <a href="macro.queue.html" title="macro bmw_util::queue"><code>crate::queue</code></a>. It is identical other than the returned value is
in a box <code>(Box&lt;dyn Queue&gt;)</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.queue_sync.html" title="macro bmw_util::queue_sync">queue_sync</a></div><div class="desc docblock-short">This is the sync version of <a href="macro.queue.html" title="macro bmw_util::queue"><code>crate::queue</code></a>. It is identical other than the returned value is
with Sync/Send traits implemented.</div></li><li><div class="item-name"><a class="macro" href="macro.queue_sync_box.html" title="macro bmw_util::queue_sync_box">queue_sync_box</a></div><div class="desc docblock-short">This is the box version of <a href="macro.queue.html" title="macro bmw_util::queue"><code>crate::queue</code></a>. It is identical other than the returned value is
in a box <code>(Box&lt;dyn Queue&gt;)</code> and Send/Sync traits implemented.</div></li><li><div class="item-name"><a class="macro" href="macro.slab_allocator.html" title="macro bmw_util::slab_allocator">slab_allocator</a></div><div class="desc docblock-short">The <code>slab_allocator</code> macro initializes a slab allocator with the specified parameters.
It takes the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.stack.html" title="macro bmw_util::stack">stack</a></div><div class="desc docblock-short">This macro creates a <a href="trait.Stack.html" title="trait bmw_util::Stack"><code>crate::Stack</code></a>. The parameters are</div></li><li><div class="item-name"><a class="macro" href="macro.stack_box.html" title="macro bmw_util::stack_box">stack_box</a></div><div class="desc docblock-short">This is the box version of <a href="macro.stack.html" title="macro bmw_util::stack"><code>crate::stack</code></a>. It is identical other than the returned value is
in a box <code>(Box&lt;dyn Stack&gt;)</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.stack_sync.html" title="macro bmw_util::stack_sync">stack_sync</a></div><div class="desc docblock-short">sync version of <a href="macro.stack.html" title="macro bmw_util::stack"><code>crate::stack</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.stack_sync_box.html" title="macro bmw_util::stack_sync_box">stack_sync_box</a></div><div class="desc docblock-short">box version of <a href="macro.stack.html" title="macro bmw_util::stack"><code>crate::stack</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.suffix_tree.html" title="macro bmw_util::suffix_tree">suffix_tree</a></div><div class="desc docblock-short">The <code>suffix_tree</code> macro builds a <a href="trait.SuffixTree.html" title="trait bmw_util::SuffixTree"><code>crate::SuffixTree</code></a> which can be used to match multiple
patterns for a given text in a performant way.
The suffix_tree macro takes the following parameters:</div></li><li><div class="item-name"><a class="macro" href="macro.thread_pool.html" title="macro bmw_util::thread_pool">thread_pool</a></div><div class="desc docblock-short">Macro used to configure/build a thread pool. See <a href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool"><code>crate::ThreadPool</code></a> for working examples.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Array.html" title="struct bmw_util::Array">Array</a></div><div class="desc docblock-short">The <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a> is essentially a wrapper around <a href="https://doc.rust-lang.org/1.73.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>std::vec::Vec</code></a>. It is mainly used
to prevent post initialization heap allocations. In many cases resizing/growing of the vec
is not needed and adding this wrapper assures that they do not happen. There are use cases
where growing is useful and in fact in the library we use Vec for the suffix tree, but in most
cases where contiguous memory is used, the primary purpose is for indexing. That can be done
with an array. So we add this wrapper.</div></li><li><div class="item-name"><a class="struct" href="struct.ArrayIterator.html" title="struct bmw_util::ArrayIterator">ArrayIterator</a></div><div class="desc docblock-short">An iterator for the <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ArrayList.html" title="struct bmw_util::ArrayList">ArrayList</a></div><div class="desc docblock-short"><a href="struct.ArrayList.html" title="struct bmw_util::ArrayList"><code>crate::ArrayList</code></a> is an array based implementation of the <a href="trait.List.html" title="trait bmw_util::List"><code>crate::List</code></a> and
<a href="trait.SortableList.html" title="trait bmw_util::SortableList"><code>crate::SortableList</code></a> trait. It uses the <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a> as it’s underlying
storage mechanism. In most cases it is more performant than the LinkedList implementation,
but it does do a heap allocation when created. See the module level documentation for
an example.</div></li><li><div class="item-name"><a class="struct" href="struct.BinReader.html" title="struct bmw_util::BinReader">BinReader</a></div><div class="desc docblock-short">Utility wrapper for an underlying byte Reader. Defines higher level methods
to write numbers, byte vectors, hashes, etc.</div></li><li><div class="item-name"><a class="struct" href="struct.BinWriter.html" title="struct bmw_util::BinWriter">BinWriter</a></div><div class="desc docblock-short">Utility wrapper for an underlying byte Writer. Defines higher level methods
to write numbers, byte vectors, hashes, etc.</div></li><li><div class="item-name"><a class="struct" href="struct.Builder.html" title="struct bmw_util::Builder">Builder</a></div><div class="desc docblock-short">The builder struct for the util library. All data structures are built through this
interface. This is used by the macros as well.</div></li><li><div class="item-name"><a class="struct" href="struct.HashsetConfig.html" title="struct bmw_util::HashsetConfig">HashsetConfig</a></div><div class="desc docblock-short">The configuration struct for a <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>Hashset</code></a>. This struct is passed
into the <a href="struct.Builder.html#method.build_hashset" title="associated function bmw_util::Builder::build_hashset"><code>crate::Builder::build_hashset</code></a> function. The <a href="https://doc.rust-lang.org/1.73.0/core/default/trait.Default.html" title="trait core::default::Default"><code>std::default::Default</code></a>
trait is implemented for this trait.</div></li><li><div class="item-name"><a class="struct" href="struct.HashsetIterator.html" title="struct bmw_util::HashsetIterator">HashsetIterator</a></div><div class="desc docblock-short">An iterator for the <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.HashtableConfig.html" title="struct bmw_util::HashtableConfig">HashtableConfig</a></div><div class="desc docblock-short">The configuration struct for a <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>Hashtable</code></a>. This struct is passed
into the <a href="struct.Builder.html#method.build_hashtable" title="associated function bmw_util::Builder::build_hashtable"><code>crate::Builder::build_hashtable</code></a> function. The <a href="https://doc.rust-lang.org/1.73.0/core/default/trait.Default.html" title="trait core::default::Default"><code>std::default::Default</code></a>
trait is implemented for this trait.</div></li><li><div class="item-name"><a class="struct" href="struct.HashtableIterator.html" title="struct bmw_util::HashtableIterator">HashtableIterator</a></div><div class="desc docblock-short">An iterator for the <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ListConfig.html" title="struct bmw_util::ListConfig">ListConfig</a></div><div class="desc docblock-short">Configuration for Lists currently there are no parameters, but it is still used
to stay consistent with <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> and <a href="trait.Hashset.html" title="trait bmw_util::Hashset"><code>crate::Hashset</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ListIterator.html" title="struct bmw_util::ListIterator">ListIterator</a></div><div class="desc docblock-short">An iterator for the <a href="trait.List.html" title="trait bmw_util::List"><code>crate::List</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Match.html" title="struct bmw_util::Match">Match</a></div><div class="desc docblock-short">A match which is returned by the suffix tree. See <a href="macro.suffix_tree.html" title="macro bmw_util::suffix_tree"><code>crate::suffix_tree!</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Pattern.html" title="struct bmw_util::Pattern">Pattern</a></div><div class="desc docblock-short">A pattern which is used with the suffix tree. See <a href="macro.suffix_tree.html" title="macro bmw_util::suffix_tree"><code>crate::suffix_tree!</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RwLockReadGuardWrapper.html" title="struct bmw_util::RwLockReadGuardWrapper">RwLockReadGuardWrapper</a></div><div class="desc docblock-short">Wrapper around the <a href="https://doc.rust-lang.org/1.73.0/std/sync/rwlock/struct.RwLockReadGuard.html" title="struct std::sync::rwlock::RwLockReadGuard"><code>std::sync::RwLockReadGuard</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RwLockWriteGuardWrapper.html" title="struct bmw_util::RwLockWriteGuardWrapper">RwLockWriteGuardWrapper</a></div><div class="desc docblock-short">Wrapper around the <a href="https://doc.rust-lang.org/1.73.0/std/sync/rwlock/struct.RwLockWriteGuard.html" title="struct std::sync::rwlock::RwLockWriteGuard"><code>std::sync::RwLockWriteGuard</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Slab.html" title="struct bmw_util::Slab">Slab</a></div><div class="desc docblock-short">Struct that is used as a immutable reference to data in a slab. See <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a> for
further details.</div></li><li><div class="item-name"><a class="struct" href="struct.SlabAllocatorConfig.html" title="struct bmw_util::SlabAllocatorConfig">SlabAllocatorConfig</a></div><div class="desc docblock-short">Slab Allocator configuration struct. This struct is the input to the
<a href="trait.SlabAllocator.html#tymethod.init" title="method bmw_util::SlabAllocator::init"><code>crate::SlabAllocator::init</code></a> function. The two parameters are <code>slab_size</code>
which is the size of the slabs in bytes allocated by this
<a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a> and <code>slab_count</code> which is the number of slabs
that can be allocated by this <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SlabMut.html" title="struct bmw_util::SlabMut">SlabMut</a></div><div class="desc docblock-short">Struct that is used as a mutable reference to data in a slab. See <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a> for
further details.</div></li><li><div class="item-name"><a class="struct" href="struct.SlabReader.html" title="struct bmw_util::SlabReader">SlabReader</a></div><div class="desc docblock-short">Utility to read from slabs using the <a href="trait.Reader.html" title="trait bmw_util::Reader"><code>bmw_ser::Reader</code></a> trait.</div></li><li><div class="item-name"><a class="struct" href="struct.SlabWriter.html" title="struct bmw_util::SlabWriter">SlabWriter</a></div><div class="desc docblock-short">Utility to write to slabs using the <a href="trait.Writer.html" title="trait bmw_util::Writer"><code>bmw_ser::Writer</code></a> trait.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadPoolConfig.html" title="struct bmw_util::ThreadPoolConfig">ThreadPoolConfig</a></div><div class="desc docblock-short">The configuration struct for a <a href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool"><code>crate::ThreadPool</code></a>. This struct is passed into the
<a href="struct.Builder.html#method.build_thread_pool" title="associated function bmw_util::Builder::build_thread_pool"><code>crate::Builder::build_thread_pool</code></a> function or the <a href="macro.thread_pool.html" title="macro bmw_util::thread_pool"><code>crate::thread_pool</code></a> macro. The
<a href="https://doc.rust-lang.org/1.73.0/core/default/trait.Default.html" title="trait core::default::Default"><code>std::default::Default</code></a> trait is implemented for this trait. Also see <a href="enum.ConfigOption.html" title="enum bmw_util::ConfigOption"><code>crate::ConfigOption</code></a>
for details on configuring via macro.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadPoolExecutor.html" title="struct bmw_util::ThreadPoolExecutor">ThreadPoolExecutor</a></div><div class="desc docblock-short">Struct that can be used to execute tasks in the thread pool. Mainly needed
for passing the execution functionality to structs/threads.</div></li><li><div class="item-name"><a class="struct" href="struct.ThreadPoolStopper.html" title="struct bmw_util::ThreadPoolStopper">ThreadPoolStopper</a></div><div class="desc docblock-short">Struct that can be used to stop the thread pool. Note the limitations
in <a href="struct.ThreadPoolStopper.html#method.stop" title="method bmw_util::ThreadPoolStopper::stop"><code>crate::ThreadPoolStopper::stop</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ConfigOption.html" title="enum bmw_util::ConfigOption">ConfigOption</a></div><div class="desc docblock-short">Configuration options used throughout this crate via macro.</div></li><li><div class="item-name"><a class="enum" href="enum.PatternParam.html" title="enum bmw_util::PatternParam">PatternParam</a></div><div class="desc docblock-short">The enum used to define patterns. See <a href="macro.pattern.html" title="macro bmw_util::pattern"><code>crate::pattern</code></a> for more info.</div></li><li><div class="item-name"><a class="enum" href="enum.PoolResult.html" title="enum bmw_util::PoolResult">PoolResult</a></div><div class="desc docblock-short">The result returned from a call to <a href="trait.ThreadPool.html#tymethod.execute" title="method bmw_util::ThreadPool::execute"><code>crate::ThreadPool::execute</code></a>. This is
similar to <a href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result"><code>std::result::Result</code></a> except that it implements <a href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Send.html" title="trait core::marker::Send"><code>std::marker::Send</code></a>
and <a href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sync.html" title="trait core::marker::Sync"><code>std::marker::Sync</code></a> so that it can be passed through threads. Also a type
<a href="enum.PoolResult.html#variant.Panic" title="variant bmw_util::PoolResult::Panic"><code>crate::PoolResult::Panic</code></a> is returned if a thread panic occurs in the thread pool.</div></li><li><div class="item-name"><a class="enum" href="enum.SuffixParam.html" title="enum bmw_util::SuffixParam">SuffixParam</a></div><div class="desc docblock-short">The enum used to define a suffix_tree. See <a href="macro.suffix_tree.html" title="macro bmw_util::suffix_tree"><code>crate::suffix_tree!</code></a> for more info.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Hashset.html" title="trait bmw_util::Hashset">Hashset</a></div><div class="desc docblock-short">A slab allocated Hashset. Most of the implementation is shared with <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a>.
See <a href="trait.Hashtable.html" title="trait bmw_util::Hashtable"><code>crate::Hashtable</code></a> for a discussion of the slab layout. The difference is that as is
the case with hashsets, there is no value.</div></li><li><div class="item-name"><a class="trait" href="trait.Hashtable.html" title="trait bmw_util::Hashtable">Hashtable</a></div><div class="desc docblock-short">A slab allocated hashtable. Data is stored in a <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a> defined
by the user or using a global thread local slab allocator. All keys and values
must implement the <a href="trait.Serializable.html" title="trait bmw_util::Serializable"><code>bmw_ser::Serializable</code></a> trait which can be implemented with
the <a href="../bmw_derive/derive.Serializable.html" title="derive bmw_derive::Serializable"><code>bmw_derive::Serializable</code></a> proc_macro.</div></li><li><div class="item-name"><a class="trait" href="trait.List.html" title="trait bmw_util::List">List</a></div><div class="desc docblock-short">A trait that defines a list. Both an array list and a linked list
are implemented the default <a href="macro.list.html" title="macro bmw_util::list"><code>crate::list</code></a> macro returns the linked list.
The <a href="macro.array_list.html" title="macro bmw_util::array_list"><code>crate::array_list</code></a> macro returns the array list. Both implement
this trait.</div></li><li><div class="item-name"><a class="trait" href="trait.Lock.html" title="trait bmw_util::Lock">Lock</a></div><div class="desc docblock-short">Wrapper around the lock functionalities used by bmw in <a href="https://doc.rust-lang.org/1.73.0/std/sync/index.html" title="mod std::sync"><code>std::sync</code></a> rust libraries.
The main benefits are the simplified interface and the fact that if a thread attempts
to obtain a lock twice, an error will be thrown instead of a thread panic. This is implemented
through a thread local Hashset which keeps track of the guards used by the lock removes an
entry for them when the guard is dropped.</div></li><li><div class="item-name"><a class="trait" href="trait.LockBox.html" title="trait bmw_util::LockBox">LockBox</a></div><div class="desc docblock-short"><a href="trait.LockBox.html" title="trait bmw_util::LockBox"><code>crate::LockBox</code></a> is the same as <a href="trait.Lock.html" title="trait bmw_util::Lock"><code>crate::Lock</code></a> except that it is possible to build
The LockBox into a Box&lt;dyn LockBox<T>&gt; structure so that it is object safe. It can then
be cloned using DynClone.</div></li><li><div class="item-name"><a class="trait" href="trait.Queue.html" title="trait bmw_util::Queue">Queue</a></div><div class="desc docblock-short">This trait defines a queue. The implementation is a bounded queue.
The queue uses an <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a> as the underlying storage mechanism.</div></li><li><div class="item-name"><a class="trait" href="trait.Reader.html" title="trait bmw_util::Reader">Reader</a></div><div class="desc docblock-short">Reader trait used for deserializing data.</div></li><li><div class="item-name"><a class="trait" href="trait.Serializable.html" title="trait bmw_util::Serializable">Serializable</a></div><div class="desc docblock-short">This is the trait used by all data structures to serialize and deserialize data.
Anything stored in them must implement this trait. Commonly needed implementations
are built in the ser module in this crate. These include Vec, String, integer types among
other things.</div></li><li><div class="item-name"><a class="trait" href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator">SlabAllocator</a></div><div class="desc docblock-short">This trait defines the public interface to the <a href="trait.SlabAllocator.html" title="trait bmw_util::SlabAllocator"><code>crate::SlabAllocator</code></a>. The slab
allocator is used by the other data structures in this crate to avoid dynamic heap
allocations. By itself, the slab allocator is fairly simple. It only allocates and frees
slabs. <a href="trait.SlabAllocator.html#tymethod.get" title="method bmw_util::SlabAllocator::get"><code>crate::SlabAllocator::get</code></a> and <a href="trait.SlabAllocator.html#tymethod.get_mut" title="method bmw_util::SlabAllocator::get_mut"><code>crate::SlabAllocator::get_mut</code></a> are also
provided to obtain immutable and mutable references to a slab respectively. They only
contain references to the data and not copies.</div></li><li><div class="item-name"><a class="trait" href="trait.SortableList.html" title="trait bmw_util::SortableList">SortableList</a></div><div class="desc docblock-short">A trait that defines a sortable list. Both implementations
implement this trait, although the linked list merely copies
the data into an array list to sort. The array_list can natively sort
with rust’s sort implementations using the functions associated
with slice.</div></li><li><div class="item-name"><a class="trait" href="trait.Stack.html" title="trait bmw_util::Stack">Stack</a></div><div class="desc docblock-short">This trait defines a stack. The implementation is a bounded stack.
The stack uses an <a href="struct.Array.html" title="struct bmw_util::Array"><code>crate::Array</code></a> as the underlying storage mechanism.</div></li><li><div class="item-name"><a class="trait" href="trait.SuffixTree.html" title="trait bmw_util::SuffixTree">SuffixTree</a></div><div class="desc docblock-short">The suffix tree data structure. See <a href="macro.suffix_tree.html" title="macro bmw_util::suffix_tree"><code>crate::suffix_tree!</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.ThreadPool.html" title="trait bmw_util::ThreadPool">ThreadPool</a></div><div class="desc docblock-short">This trait defines the public interface to the ThreadPool. A pool can be configured
via the <a href="struct.ThreadPoolConfig.html" title="struct bmw_util::ThreadPoolConfig"><code>crate::ThreadPoolConfig</code></a> struct. The thread pool should be accessed through the
macros under normal circumstances. See <a href="macro.thread_pool.html" title="macro bmw_util::thread_pool"><code>crate::thread_pool</code></a>, <a href="macro.execute.html" title="macro bmw_util::execute"><code>crate::execute</code></a> and
<a href="macro.block_on.html" title="macro bmw_util::block_on"><code>crate::block_on</code></a> for additional details. The thread pool can be passed through threads via a
<a href="trait.Lock.html" title="trait bmw_util::Lock"><code>crate::Lock</code></a> or <a href="trait.LockBox.html" title="trait bmw_util::LockBox"><code>crate::LockBox</code></a> so a single thread pool can service multiple
worker threads. See examples below.</div></li><li><div class="item-name"><a class="trait" href="trait.Writer.html" title="trait bmw_util::Writer">Writer</a></div><div class="desc docblock-short">Writer trait used to serializing data.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.deserialize.html" title="fn bmw_util::deserialize">deserialize</a></div><div class="desc docblock-short">Deserializes a Serializable from any std::io::Read implementation.</div></li><li><div class="item-name"><a class="fn" href="fn.lock_box_from_usize.html" title="fn bmw_util::lock_box_from_usize">lock_box_from_usize</a></div><div class="desc docblock-short">Rebuild a <a href="trait.LockBox.html" title="trait bmw_util::LockBox"><code>crate::LockBox</code></a> from te usize which is returned from the
<a href="trait.LockBox.html#tymethod.danger_to_usize" title="method bmw_util::LockBox::danger_to_usize"><code>crate::LockBox::danger_to_usize</code></a> function.</div></li><li><div class="item-name"><a class="fn" href="fn.serialize.html" title="fn bmw_util::serialize">serialize</a></div><div class="desc docblock-short">Serializes a Serializable into any std::io::Write implementation.</div></li></ul></section></div></main></body></html>